\section{Сравнение полученных реализаций}
Проведем анализ производительности полученных версий анализатора. В
качестве данных для тестирования возьмем выражения вида а 2 + 2 + 2 · · · + 2
| {z }
n
для n = 1 . . . 100 с шагом 1. Для вычисления времени выполнения воспользуемся библиотекой time Python 3.9.5. Автоматизацию обеспечим с помощью
библиотеки subprocess. Получим следующий код:

\inputminted{python}{requirements/src/test.py}

Кроме того, отметим, что в ранее написанные программы были внесены некоторые изменения для проведения эксперимента. Ознакомиться с ними
можно в приложении А.

Ознакомиться с полным исходным кодом программы, осуществляющей
исследование производительности можно в приложении Б.

Для большей наглядности графики интерполированы полиномом с помощью функции polyfit библиотеки numpy.

Ознакомиться с полным исходным кодом программы, осуществляющей
анализ полученных результатов можно в приложении В.

Результаты исследования изображены на рис. 7:

\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{benchmark.png}
    \caption{Сравнение полученных результатов}
    \label{fig:seven}
\end{figure}

Исследование показало, что использование абстрактных синтаксических
деревьев позволяет уменьшить время работы программы более чем в 5 раз, что
существенно заметно для выражений любой длины.

Также из графиков видно, что в рамках данной работы не удалось добиться большей производительности при управлении памятью на основе регионов.
Тем не менее, она все еще может считаться более предпочительной ввиду перечисленных ранее преимуществ.
